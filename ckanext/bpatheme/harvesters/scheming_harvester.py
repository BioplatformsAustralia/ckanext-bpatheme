import urllib2

from ckan.lib.base import c
from ckan import model
from ckan.model import Session, Package
from ckan.logic import ValidationError, NotFound, get_action
from ckan.lib.helpers import json
from ckan.lib.munge import munge_name

from ckanext.harvest.harvesters import CKANHarvester


import logging

log = logging.getLogger(__name__)

from base import HarvesterBase


class CKANSchemingHarvester(CKANHarvester):
    """
    A Harvester for CKAN instances with custom scheming dataset
    """

    def info(self):
        return {
            "name": "ckan-scheming",
            "title": "CKAN-scheming",
            "description": "Harvests remote CKAN instances with ckanext-scheming",
            "form_config_interface": "Text",
        }

    def import_stage(self, harvest_object):
        log.debug("In CKANHarvester import_stage")

        context = {"model": model, "session": Session, "user": self._get_user_name()}
        if not harvest_object:
            log.error("No harvest object received")
            return False

        if harvest_object.content is None:
            self._save_object_error(
                "Empty content for object %s" % harvest_object.id,
                harvest_object,
                "Import",
            )
            return False

        self._set_config(harvest_object.job.source.config)

        try:
            package_dict = json.loads(harvest_object.content)

            if package_dict.get("type") == "harvest":
                log.warn("Remote dataset is a harvest source, ignoring...")
                return True

            # Set default tags if needed
            default_tags = self.config.get("default_tags", [])
            if default_tags:
                if not "tags" in package_dict:
                    package_dict["tags"] = []
                package_dict["tags"].extend(
                    [t for t in default_tags if t not in package_dict["tags"]]
                )

            remote_groups = self.config.get("remote_groups", None)
            if not remote_groups in ("only_local", "create"):
                # Ignore remote groups
                package_dict.pop("groups", None)
            else:
                if not "groups" in package_dict:
                    package_dict["groups"] = []

                # check if remote groups exist locally, otherwise remove
                validated_groups = []

                for group_name in package_dict["groups"]:
                    try:
                        data_dict = {"id": group_name}
                        group = get_action("group_show")(context, data_dict)
                        if self.api_version == 1:
                            validated_groups.append(group["name"])
                        else:
                            validated_groups.append(group["id"])
                    except NotFound, e:
                        log.info("Group %s is not available" % group_name)
                        if remote_groups == "create":
                            try:
                                group = self._get_group(
                                    harvest_object.source.url, group_name
                                )
                            except RemoteResourceError:
                                log.error("Could not get remote group %s" % group_name)
                                continue

                            for key in [
                                "packages",
                                "created",
                                "users",
                                "groups",
                                "tags",
                                "extras",
                                "display_name",
                            ]:
                                group.pop(key, None)

                            get_action("group_create")(context, group)
                            log.info("Group %s has been newly created" % group_name)
                            if self.api_version == 1:
                                validated_groups.append(group["name"])
                            else:
                                validated_groups.append(group["id"])

                package_dict["groups"] = validated_groups

            # Local harvest source organization
            source_dataset = get_action("package_show")(
                context, {"id": harvest_object.source.id}
            )
            local_org = source_dataset.get("owner_org")

            remote_orgs = self.config.get("remote_orgs", None)

            if not remote_orgs in ("only_local", "create"):
                # Assign dataset to the source organization
                package_dict["owner_org"] = local_org
            else:
                if not "owner_org" in package_dict:
                    package_dict["owner_org"] = None

                # check if remote org exist locally, otherwise remove
                validated_org = None
                remote_org = package_dict["owner_org"]

                if remote_org:
                    try:
                        data_dict = {"id": remote_org}
                        org = get_action("organization_show")(context, data_dict)
                        validated_org = org["id"]
                    except NotFound, e:
                        log.info("Organization %s is not available" % remote_org)
                        if remote_orgs == "create":
                            try:
                                try:
                                    org = self._get_organization(
                                        harvest_object.source.url, remote_org
                                    )
                                except RemoteResourceError:
                                    # fallback if remote CKAN exposes organizations as groups
                                    # this especially targets older versions of CKAN
                                    org = self._get_group(
                                        harvest_object.source.url, remote_org
                                    )

                                for key in [
                                    "packages",
                                    "created",
                                    "users",
                                    "groups",
                                    "tags",
                                    "extras",
                                    "display_name",
                                    "type",
                                ]:
                                    org.pop(key, None)
                                get_action("organization_create")(context, org)
                                log.info(
                                    "Organization %s has been newly created"
                                    % remote_org
                                )
                                validated_org = org["id"]
                            except (RemoteResourceError, ValidationError):
                                log.error("Could not get remote org %s" % remote_org)

                package_dict["owner_org"] = validated_org or local_org

            # Set default groups if needed
            default_groups = self.config.get("default_groups", [])
            if default_groups:
                if not "groups" in package_dict:
                    package_dict["groups"] = []
                package_dict["groups"].extend(
                    [g for g in default_groups if g not in package_dict["groups"]]
                )

            # FIXME: enable only if not using ckanext-scheming dataset schemas
            # handle extras in harvested schema
            #
            """
            # Find any extras whose values are not strings and try to convert
            # them to strings, as non-string extras are not allowed anymore in
            # CKAN 2.0.
	    for key in package_dict['extras'].keys():
                if not isinstance(package_dict['extras'][key], basestring):
                    try:
                        package_dict['extras'][key] = json.dumps(
                                package_dict['extras'][key])
                    except TypeError:
                        # If converting to a string fails, just delete it.
                        del package_dict['extras'][key]

            # Set default extras if needed
            default_extras = self.config.get('default_extras',{})
            if default_extras:
                override_extras = self.config.get('override_extras',False)
                if not 'extras' in package_dict:
                    package_dict['extras'] = {}
                for key,value in default_extras.iteritems():
                    if not key in package_dict['extras'] or override_extras:
                        # Look for replacement strings
                        if isinstance(value,basestring):
                            value = value.format(harvest_source_id=harvest_object.job.source.id,
                                     harvest_source_url=harvest_object.job.source.url.strip('/'),
                                     harvest_source_title=harvest_object.job.source.title,
                                     harvest_job_id=harvest_object.job.id,
                                     harvest_object_id=harvest_object.id,
                                     dataset_id=package_dict['id'])

                        package_dict['extras'][key] = value
	    """

            # Clear remote url_type for resources (eg datastore, upload) as we
            # are only creating normal resources with links to the remote ones
            for resource in package_dict.get("resources", []):
                resource.pop("url_type", None)

            result = self._create_or_update_package(package_dict, harvest_object)

            if result and self.config.get("read_only", False) == True:

                package = model.Package.get(package_dict["id"])

                # Clear default permissions
                model.clear_user_roles(package)

                # Setup harvest user as admin
                user_name = self.config.get("user", u"harvest")
                user = model.User.get(user_name)
                pkg_role = model.PackageRole(
                    package=package, user=user, role=model.Role.ADMIN
                )

                # Other users can only read
                for user_name in (u"visitor", u"logged_in"):
                    user = model.User.get(user_name)
                    pkg_role = model.PackageRole(
                        package=package, user=user, role=model.Role.READER
                    )

            return True
        except ValidationError, e:
            self._save_object_error(
                "Invalid package with GUID %s: %r"
                % (harvest_object.guid, e.error_dict),
                harvest_object,
                "Import",
            )
        except Exception, e:
            self._save_object_error("%r" % e, harvest_object, "Import")
